#ifdef GL_ES
precision mediump float; // Required for WebGL fragment shaders
#endif

// ====================
// Uniforms
// ====================
uniform float time;        // Animation time
uniform vec2 resolution;   // Screen resolution (width, height)
uniform sampler2D backbuffer; // Currently unused (for potential feedback)

// ====================
// Hash & Noise Utilities
// ====================

// Simple 2D hash function
float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

// 2D pseudo-Perlin noise
float noise(vec2 p) {
    vec2 i = floor(p);   // Cell coordinates
    vec2 f = fract(p);   // Local coordinates

    // Corner values
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    // Smooth interpolation
    vec2 u = f * f * (3.0 - 2.0 * f);

    // Bilinear interpolation with offsets
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
}

// ====================
// Main Shader
// ====================
void main() {
    // Normalize pixel coordinates to [0,1]
    vec2 uv = gl_FragCoord.xy / resolution.xy;

    // Noise scale factor
    float scale = 1.5;

    // Animated noise
    float n = noise(uv * scale + vec2(time * 0.03, time * 0.03));

    // Vertical broken lines with noise distortion
    float linesV = smoothstep(0.48, 0.52, fract(uv.x * scale + n * 0.5))
                 - smoothstep(0.48, 0.52, fract(uv.x * scale + n * 0.26));

    // Horizontal broken lines with noise distortion
    float linesH = smoothstep(0.48, 0.52, fract(uv.y * scale + n * 0.5))
                 - smoothstep(0.48, 0.52, fract(uv.y * scale + n * 0.25));

    // Combine vertical and horizontal patterns
    float pattern = max(linesV, linesH);

    // Apply contrast boost
    float color = pow(pattern, 3.0);

    // Output grayscale color
    gl_FragColor = vec4(vec3(color), 1.0);
}
